/ MARIE Practical Test 17 August 2023

/ enter value of n, where n > 0
input 
store n

main,   jns input_arr

        /jns output_array

        jns bubble_sort

        jns output_array

        jns output_min_max_product

        jns output_median

        halt

/ input n integers to array
input_arr, hex 0
input_loop, input 
            storei arr_ptr1

            / point to next array element
            load arr_ptr1
            add one
            store arr_ptr1

            / i += 1
            load i
            add one
            store i

            / if i = n, stop
            subt n
            skipcond 400
            jump input_loop
            jumpi input_arr

/ START OF BUBBLE SORT
bubble_sort,    hex  0
                load zero
                store i / i = 0
            
                / arr_ptr1 = arr_start
                load arr_start
                store arr_ptr1

                jns outer_loop_start
                jumpi bubble_sort

outer_loop_start, hex 0

outer_loop,     load i
				/ check if i < n - 1
				subt n
                add one
                Skipcond 000
                jumpi outer_loop_start
                
                / j = 0, swapped = 0
				load zero
                store j
                store swapped
                
                load arr_start
				store arr_ptr2
                
                jns start_inner_loop 
                
                / check if no swapping took place
                load swapped 
                skipcond 800
                jumpi outer_loop_start / end outer loop
                / if swapped > 0, 
                
                / i += 1
                load i
                add one
                store i
                
                load arr_ptr1
				add one
                store arr_ptr1
                
                jump outer_loop

start_inner_loop, hex 0

inner_loop, load j 
			/ check if j < n - 1 - i. If so, continue, else go back to outer loop
            subt n
            add i
            add one
            Skipcond 000
            jumpi start_inner_loop
            
            / get pointer to next element
            / arr_ptr3 = arr_ptr2 + 1
			load arr_ptr2
			add one
            store arr_ptr3
            
            / temp =  arr[j+1]
            loadi arr_ptr3
            store temp                       
            
            / check if arr[j] < arr[j+1]
            loadi arr_ptr2
            subt temp
            skipcond 000
            jns start_swap	/ skip swapping if arr[j] <= arr[j+1]
            
            / j += 1
            load j
            add one
            store j
            
            / update pointer to arr[j]
            load arr_ptr2
            add one
            store arr_ptr2
            
            jump inner_loop


/ swap elements of array pointed by arr_ptr2 and arr_ptr3
start_swap, hex 0
swap, 	loadi arr_ptr2
		store temp
        
        LoadI arr_ptr3
        storei arr_ptr2
        
        load temp
        storei arr_ptr3
        
        / set swapped to 1
        load one
        store swapped
        
        JumpI start_swap
            
/ END OF BUBBLE SORT

/ START OF OUTPUT ARRAY
output_array,   hex 0
                load arr_start
                store arr_ptr1
                load zero
                store i

output_loop,    loadi arr_ptr1
                output

                load arr_ptr1
                add one
                store arr_ptr1

                / i += 1
                load i
                add one
                store i

                subt n
                skipcond 400
                jump output_loop
                jumpi output_array
/ END OF OUTPUT ARRAY

/ START FOR MULTIPLICATION
output_min_max_product, hex 0

                        / initialise a, b to min and max elements of array
                        jns get_arr_min_max


                        jns check_product_sign
                        jns make_a_pos
                        jns make_b_pos
                        

                        / i = 0
                        clear
                        store i
                        
                        jns mult

                        / check true sign of product
                        load negative
                        Skipcond 400
                        jump output_negative_product

                        / Output  positive product
                        load product
                        output
                        jumpi output_min_max_product

/ a = arr[0] and b = arr[n-1]
get_arr_min_max,    hex 0
					loadi arr_start                    
                    store a

                    load arr_start
                    add n
                    subt one
                    store arr_ptr1

                    loadi arr_ptr1
                    store b

                    jumpi get_arr_min_max


check_product_sign, hex 0
			load a
			Skipcond 000
            jump check_sign_given_a_pos/ do if a >= 0
            
            / if a < 0
            load b 
            Skipcond 000
            jump set_neg_true / a < 0 and b > 0
            JumpI check_product_sign / a < 0 and b < 0

check_sign_given_a_pos,   	load b 
            				Skipcond 000
            				JumpI check_product_sign / a >= 0 and b >= 0
            				jump set_neg_true / a >= 0 and b < 0

/ negative = 1 and returns to main
set_neg_true, 	load one
				store negative
                JumpI check_product_sign

/ a =  abs(a)
make_a_pos, 	hex 0
				load a
				Skipcond 000
                jumpi make_a_pos
				load zero
				subt a
        		store a
                jumpi make_a_pos
                
/ b = abs(b)
make_b_pos, 	hex 0
				load b
				skipcond 000
                jumpi make_b_pos
				load zero
				subt b
                store b
                jumpi make_b_pos
 
output_negative_product,	load zero
                            Subt  product
                            store product
                            output
                            jumpi output_min_max_product
					

/ performs product = abs(a) * abs(b), where abs(a) >= abs(b)            
mult,	hex 0
		load a
		subt b
        
        / a < b ?
        skipcond 000
        Jump mult_loop
		
        / swap a and b
        load a
        store temp
        
        load b
        store a
        
        load temp
        store b
        
mult_loop, 	load i
			subt b
            / i < b ?
            skipcond 000
            JumpI mult

			load product
            add a / product += a
            store product

            / i++
            load i
            add one
            store i

            jump mult_loop

/ END FOR MULTIPLICATION

output_median,  hex 0
                / reset negative
                clear 
                store negative

                / calculate (n div 2)
                / remainder and quotient are also calculated

                jumpi output_median


/ constants
zero, dec 0
one, dec 1
n, dec 0 / size of array
arr_start, hex 400 / start of array

/ variables
temp, dec 0 / a variable for temporary storage
a, dec 0 / multiplier
b, dec 0 / multiplicand
product, dec 0 / stores product of minimum and maximum value of array
negative, dec 0 / Indicates whether product should be positive or negative. Initially false. 
swapped, dec 0 / Indicates whether a swap was performed in inner loop of bubble sort

/ loop counters
i, dec 0
j, dec 0

/ array pointers
arr_ptr1, hex 400  / pointer of array. initial value = start of array
arr_ptr2, hex 0
arr_ptr3, hex 0