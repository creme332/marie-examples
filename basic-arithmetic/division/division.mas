input 
store dividend
store dvd_copy

input 
store divisor

/ if divisor = 0, halt
skipcond 400
jump main
Halt

main, 	jns check_sign / determine sign of quotient

		/ calculate abs(dividend) / abs(divisor)
		jns make_dvd_pos
		jns make_dvs_pos
		jns call_loop
    
        jns abc
		jns both_dvd_and_dvs_neg
        
		/ output quotient
		load quotient
		output

		/ output remainder
		load remainder
		output

        halt

/ both original dividend and divisor were negative.
both_dvd_and_dvs_neg,	hex 0
						/ verify that both dividend and divisor were negative
						load negative
						Skipcond 400
                        jumpi both_dvd_and_dvs_neg

						load dvd_copy
        				skipcond 000
                        jumpi both_dvd_and_dvs_neg
                        
                        / quotient + 1
                        load quotient
                        add one
                        store quotient
                        
                        / remainder = divisor - remainder
                        load divisor
						subt remainder
                        store remainder
                        
                        jumpi both_dvd_and_dvs_neg
                        
abc, hex 0		
update_on_negative,  load zero
					load negative
					skipcond 800 / if not negative, go back to main and output positive value
					jumpi abc

					/ quotient = - quotient
					load zero
					subt quotient
					store quotient

					/ if original dividend < 0, 
					load dvd_copy
					skipcond 000 / original dividend > 0
					jumpi abc

					/ if original dividend < 0, 

					/ quotient --
					load quotient
					subt one
					store quotient

					/ remainder = divisor - remainder
					load divisor
					subt remainder
					store remainder

					jumpi abc
                 
check_sign, hex 0
			load dividend
			Skipcond 000
            jump check_sign_given_dvd_pos / do if a >= 0
            
            / if dividend < 0, check if divisor < 0
            load divisor 
            Skipcond 000
            jump set_neg_true / a < 0 and b > 0
            JumpI check_sign / a < 0 and b < 0

check_sign_given_dvd_pos,   	load divisor 
            					Skipcond 000
            					JumpI check_sign / a >= 0 and b >= 0
                                jump set_neg_true / a >= 0 and b < 0

/ negative = 1 and returns to main
set_neg_true, 	load one
				store negative
                JumpI check_sign

make_dvd_pos, 	hex 0
				load dividend
				Skipcond 000
                jumpi make_dvd_pos
                
                / dividend = - dividend
				load zero
				subt dividend
        		store dividend
                
                jumpi make_dvd_pos
                
make_dvs_pos, 	hex 0
				load divisor
				Skipcond 000
                jumpi make_dvs_pos
                
                / divisor = - divisor
				load zero
				subt divisor
        		store divisor
                
                jumpi make_dvs_pos
                
call_loop, hex 0
loop, 	load dividend
		subt divisor
        add one

        / check if dividend - divisor >= 0 (or > -1)
		Skipcond 800
        jump end_loop
  
        / dividend -= divisor
		subt one
        store dividend
        
        / quotient += 1
		load quotient	
        add one
        store quotient
        
        jump loop

end_loop,	subt one / remove the extra one added when checking if loop should end
			add divisor
        	store remainder
			jumpi call_loop / end loop if acc < 0

negative, dec 0 / boolean. if 1, quotient must be negative. else, quotient positive.
one, dec 1 / constant
zero, dec 0 / constant
remainder, dec 0
quotient, dec 0
dividend, dec 0
dvd_copy, dec 0
divisor, dec 0